<!DOCTYPE html>
<html lang="zh-Hans">
    <!-- title -->




<!-- keywords -->




<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="author" content="leisurexi">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="leisurexi">
    
    <meta name="keywords" content="hexo,hexo-theme,hexo-blog">
    
    <meta name="description" content="此行一入深似海，从此红尘是路人。">
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>HashMap · leisurexi&#39;s Blog</title>
    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }

</style>

    <link rel="preload" href="/css/style.css?v=20180824" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link rel="stylesheet" href="/css/mobile.css?v=20180824" media="(max-width: 980px)">
    
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
(function( w ){
	"use strict";
	// rel=preload support test
	if( !w.loadCSS ){
		w.loadCSS = function(){};
	}
	// define on the loadCSS obj
	var rp = loadCSS.relpreload = {};
	// rel=preload feature support test
	// runs once and returns a function for compat purposes
	rp.support = (function(){
		var ret;
		try {
			ret = w.document.createElement( "link" ).relList.supports( "preload" );
		} catch (e) {
			ret = false;
		}
		return function(){
			return ret;
		};
	})();

	// if preload isn't supported, get an asynchronous load by using a non-matching media attribute
	// then change that media back to its intended value on load
	rp.bindMediaToggle = function( link ){
		// remember existing media attr for ultimate state, or default to 'all'
		var finalMedia = link.media || "all";

		function enableStylesheet(){
			link.media = finalMedia;
		}

		// bind load handlers to enable media
		if( link.addEventListener ){
			link.addEventListener( "load", enableStylesheet );
		} else if( link.attachEvent ){
			link.attachEvent( "onload", enableStylesheet );
		}

		// Set rel and non-applicable media type to start an async request
		// note: timeout allows this to happen async to let rendering continue in IE
		setTimeout(function(){
			link.rel = "stylesheet";
			link.media = "only x";
		});
		// also enable media after 3 seconds,
		// which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
		setTimeout( enableStylesheet, 3000 );
	};

	// loop through link elements in DOM
	rp.poly = function(){
		// double check this to prevent external calls from running
		if( rp.support() ){
			return;
		}
		var links = w.document.getElementsByTagName( "link" );
		for( var i = 0; i < links.length; i++ ){
			var link = links[ i ];
			// qualify links to those with rel=preload and as=style attrs
			if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
				// prevent rerunning on link
				link.setAttribute( "data-loadcss", true );
				// bind listeners to toggle media back
				rp.bindMediaToggle( link );
			}
		}
	};

	// if unsupported, run the polyfill
	if( !rp.support() ){
		// run once at least
		rp.poly();

		// rerun poly on an interval until onload
		var run = w.setInterval( rp.poly, 500 );
		if( w.addEventListener ){
			w.addEventListener( "load", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		} else if( w.attachEvent ){
			w.attachEvent( "onload", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		}
	}


	// commonjs
	if( typeof exports !== "undefined" ){
		exports.loadCSS = loadCSS;
	}
	else {
		w.loadCSS = loadCSS;
	}
}( typeof global !== "undefined" ? global : this ) );
</script>

    <link rel="icon" href="/assets/favicon.ico">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js" as="script">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" as="script">
    <link rel="preload" href="/scripts/main.js" as="script">
    <link rel="preload" as="font" href="/font/Oswald-Regular.ttf" crossorigin>
    <link rel="preload" as="font" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" crossorigin>
    
    <!-- fancybox -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script>
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
</head>

    
        <body class="post-body">
    
    
<header class="header">

    <div class="read-progress"></div>
    <div class="header-sidebar-menu">&#xe775;</div>
    <!-- post页的toggle banner  -->
    
    <div class="banner">
            <div class="blog-title">
                <a href="/" >leisurexi&#39;s Blog.</a>
            </div>
            <div class="post-title">
                <a href="#" class="post-name">HashMap</a>
            </div>
    </div>
    
    <a class="home-link" href=/>leisurexi's Blog.</a>
</header>
    <div class="wrapper">
        <div class="site-intro" style="







height:50vh;
">
    
    <!-- 主页  -->
    
    
    <!-- 404页  -->
            
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(/intro/post-bg.jpg)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
            HashMap
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
            
            <!-- 404 -->
            
        </p>
        <!-- 文章页meta -->
        
            <div class="post-intros">
                <!-- 文章页标签  -->
                
                    <div class= post-intro-tags >
    
        <a class="post-tag" href="javascript:void(0);" data-tags = "集合">集合</a>
    
</div>
                
                
                    <div class="post-intro-read">
                        <span>字数统计: <span class="post-count word-count">12.1k</span>阅读时长: <span class="post-count reading-time">52 min</span></span>
                    </div>
                
                <div class="post-intro-meta">
                    <span class="post-intro-calander iconfont-archer">&#xe676;</span>
                    <span class="post-intro-time">2019/08/15</span>
                    
                    <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                        <span class="iconfont-archer">&#xe602;</span>
                        <span id="busuanzi_value_page_pv"></span>
                    </span>
                    
                    <span class="shareWrapper">
                        <span class="iconfont-archer shareIcon">&#xe71d;</span>
                        <span class="shareText">Share</span>
                        <ul class="shareList">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
        
    </div>
</div>
        <script>
 
  // get user agent
  var browser = {
    versions: function () {
      var u = window.navigator.userAgent;
      return {
        userAgent: u,
        trident: u.indexOf('Trident') > -1, //IE内核
        presto: u.indexOf('Presto') > -1, //opera内核
        webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
        gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
        mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
        ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
        android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
        iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
        iPad: u.indexOf('iPad') > -1, //是否为iPad
        webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
        weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
        uc: u.indexOf('UCBrowser') > -1 //是否为android下的UC浏览器
      };
    }()
  }
  console.log("userAgent:" + browser.versions.userAgent);

  // callback
  function fontLoaded() {
    console.log('font loaded');
    if (document.getElementsByClassName('site-intro-meta')) {
      document.getElementsByClassName('intro-title')[0].classList.add('intro-fade-in');
      document.getElementsByClassName('intro-subtitle')[0].classList.add('intro-fade-in');
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in');
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb(){
    if (browser.versions.uc) {
      console.log("UCBrowser");
      fontLoaded();
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular']
        },
        loading: function () {  //所有字体开始加载
          // console.log('loading');
        },
        active: function () {  //所有字体已渲染
          fontLoaded();
        },
        inactive: function () { //字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout');
          fontLoaded();
        },
        timeout: 5000 // Set the timeout to two seconds
      });
    }
  }

  function asyncErr(){
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (cb) { o.addEventListener('load', function (e) { cb(null, e); }, false); }
    if (err) { o.addEventListener('error', function (e) { err(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }

  var asyncLoadWithFallBack = function(arr, success, reject) {
      var currReject = function(){
        reject()
        arr.shift()
        if(arr.length)
          async(arr[0], success, currReject)
        }

      async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack([
    "https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js", 
    "https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js",
    "/lib/webfontloader.min.js"
  ], asyncCb, asyncErr)
</script>        
        <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
        <div class="container container-unloaded">
            <main class="main post-page">
    <article class="article-entry">
        <p>这章开始我们对Map的具体实现类来进行介绍，首先是HashMap，而Map中HashMap是最常用的。</p>
<a id="more"></a>

<h1 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The default initial capacity - MUST be a power of two.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// 默认容量16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The maximum capacity, used if a higher value is implicitly specified</span></span><br><span class="line"><span class="comment"> * by either of the constructors with arguments.</span></span><br><span class="line"><span class="comment"> * MUST be a power of two &lt;= 1&lt;&lt;30.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>; <span class="comment">//最大容量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The load factor used when none specified in constructor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>; <span class="comment">//默认负载因子0.75</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The bin count threshold for using a tree rather than list for a</span></span><br><span class="line"><span class="comment"> * bin.  Bins are converted to trees when adding an element to a</span></span><br><span class="line"><span class="comment"> * bin with at least this many nodes. The value must be greater</span></span><br><span class="line"><span class="comment"> * than 2 and should be at least 8 to mesh with assumptions in</span></span><br><span class="line"><span class="comment"> * tree removal about conversion back to plain bins upon</span></span><br><span class="line"><span class="comment"> * shrinkage.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>; <span class="comment">//链表节点转红黑树节点阈值9个节点转</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The bin count threshold for untreeifying a (split) bin during a</span></span><br><span class="line"><span class="comment"> * resize operation. Should be less than TREEIFY_THRESHOLD, and at</span></span><br><span class="line"><span class="comment"> * most 6 to mesh with shrinkage detection under removal.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>; <span class="comment">//红黑树转链表节点阈值6个节点转</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The smallest table capacity for which bins may be treeified.</span></span><br><span class="line"><span class="comment"> * (Otherwise the table is resized if too many nodes in a bin.)</span></span><br><span class="line"><span class="comment"> * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts</span></span><br><span class="line"><span class="comment"> * between resizing and treeification thresholds.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>; <span class="comment">// 转红黑树时，table最小长度</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Basic hash bin node, used for most entries.  (See below for</span></span><br><span class="line"><span class="comment"> * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123; <span class="comment">//基本的hash节点，继承自Map.Entry</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The table, initialized on first use, and resized as</span></span><br><span class="line"><span class="comment">    * necessary. When allocated, length is always a power of two.</span></span><br><span class="line"><span class="comment">    * (We also tolerate length zero in some operations to allow</span></span><br><span class="line"><span class="comment">    * bootstrapping mechanics that are currently not needed.)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">transient</span> Node&lt;K,V&gt;[] table; <span class="comment">//存放节点的数组，又叫作桶（bucket）</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Holds cached entrySet(). Note that AbstractMap fields are used</span></span><br><span class="line"><span class="comment">    * for keySet() and values().</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet; <span class="comment">//作为entrySet()的缓存</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The number of key-value mappings contained in this map.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">transient</span> <span class="keyword">int</span> size; <span class="comment">//实际节点个数</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The number of times this HashMap has been structurally modified</span></span><br><span class="line"><span class="comment">    * Structural modifications are those that change the number of mappings in</span></span><br><span class="line"><span class="comment">    * the HashMap or otherwise modify its internal structure (e.g.,</span></span><br><span class="line"><span class="comment">    * rehash).  This field is used to make iterators on Collection-views of</span></span><br><span class="line"><span class="comment">    * the HashMap fail-fast.  (See ConcurrentModificationException).</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">transient</span> <span class="keyword">int</span> modCount; <span class="comment">//集合修改次数</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The next size value at which to resize (capacity * load factor).</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">// (The javadoc description is true upon serialization.</span></span><br><span class="line">   <span class="comment">// Additionally, if the table array has not been allocated, this</span></span><br><span class="line">   <span class="comment">// field holds the initial array capacity, or zero signifying</span></span><br><span class="line">   <span class="comment">// DEFAULT_INITIAL_CAPACITY.)</span></span><br><span class="line">   <span class="keyword">int</span> threshold; <span class="comment">//扩容的阈值 = table.length * loadFactor </span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The load factor for the hash table.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">float</span> loadFactor; <span class="comment">//负载因子</span></span><br></pre></td></tr></table></figure>

<h1 id="静态工具方法"><a href="#静态工具方法" class="headerlink" title="静态工具方法"></a>静态工具方法</h1><h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> h;</span><br><span class="line">      <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><code>key</code>的<code>hash</code>值高16不变，低16位与高16位异或作为<code>key</code>的最终<code>hash</code>值 。（h &gt;&gt;&gt; 16）代表无符号右移16位，高位补0，任何数跟0异或都是其本身，因此<code>key</code>的<code>hash</code>值高16位不变。</p>
<p>整个过程本质上就是三步：</p>
<ol>
<li>拿到<code>key</code>的<code>hashCode</code>值</li>
<li>将<code>hashCode</code>值高位参与运算，重新计算<code>hash</code>值</li>
<li>将计算出的<code>hash</code>值与<code>(table.length - 1)</code>进行<code>&amp;</code>运算</li>
</ol>
<h2 id="compareComparables"><a href="#compareComparables" class="headerlink" title="compareComparables"></a>compareComparables</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Class&lt;?&gt; comparableClassFor(Object x) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x <span class="keyword">instanceof</span> Comparable) &#123;</span><br><span class="line">        Class&lt;?&gt; c; Type[] ts, as; Type t; ParameterizedType p;</span><br><span class="line">        <span class="keyword">if</span> ((c = x.getClass()) == String.class) <span class="comment">// bypass checks</span></span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        <span class="keyword">if</span> ((ts = c.getGenericInterfaces()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ts.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (((t = ts[i]) <span class="keyword">instanceof</span> ParameterizedType) &amp;&amp;</span><br><span class="line">                    ((p = (ParameterizedType)t).getRawType() ==</span><br><span class="line">                     Comparable.class) &amp;&amp;</span><br><span class="line">                    (as = p.getActualTypeArguments()) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                    as.length == <span class="number">1</span> &amp;&amp; as[<span class="number">0</span>] == c) <span class="comment">// type arg is c</span></span><br><span class="line">                    <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果x实现了Comparable接口就返回x的Class对象，否则返回null。</p>
<h2 id="compareComparables-1"><a href="#compareComparables-1" class="headerlink" title="compareComparables"></a>compareComparables</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compareComparables</span><span class="params">(Class&lt;?&gt; kc, Object k, Object x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x == <span class="keyword">null</span> || x.getClass() != kc ? <span class="number">0</span> :</span><br><span class="line">            ((Comparable)k).compareTo(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果x的Class对象等于kc，就调用compareTo返回比较结果，否则返回0。</p>
<h2 id="tableSizeFor"><a href="#tableSizeFor" class="headerlink" title="tableSizeFor"></a>tableSizeFor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用于找到大于等于cap的最小2的幂，如果cap就是2的幂则返回的还是这个数。</p>
<p>对这个方法解释的比较好的一篇<a href="https://blog.csdn.net/fan2012huan/article/details/51097331" target="_blank" rel="noopener">博客</a>。</p>
<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>先检查<code>initialCapacity</code>和<code>loadFactor</code>参数值是否正确。</li>
<li>给<code>loadFactor</code>（负载因子）和 <code>threshold</code>（扩容阈值）赋值，这里<code>threshold</code>调用了<code>tableSizeFor</code>保证了时2的幂，但是没有乘<code>table.length</code>是因为<code>table</code>没有在构造函数中初始化还是在<code>put</code>方法中初始化，同时在<code>put</code>方法中也会重新对<code>threshold</code>赋值。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这个方法就是调用了上面的方法，只不过<code>loadFactor</code>给了默认值<code>0.75</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这个方法没有任何参数，代表<code>initialCapacity</code>和<code>loadFactor</code>都使用默认值，分别为<code>16</code>和<code>0.75</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">       putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这个方法给<code>loadFactor</code>赋默认值<code>0.75</code>，然后调用<code>putMapEntries</code>方法将参数传进来的<code>Map</code>元素全部加入到<code>table</code>中。</p>
<p><code>putMapEntries</code>会在下面的常用方法介绍。</p>
<h1 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h1><p><strong>与红黑树相关（TreeNode）的方法会在后面单独介绍</strong>。</p>
<h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">     Node&lt;K,V&gt; e;</span><br><span class="line">     <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>调用<code>getNode</code>方法传入<code>key</code>和<code>key</code>的<code>hash</code>值，如果为<code>null</code>直接返回<code>null</code>否则返回节点的<code>value</code>值。</p>
<h2 id="getNode"><a href="#getNode" class="headerlink" title="getNode"></a>getNode</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">  	<span class="comment">//table不为空并且table长度大于0，table的根据hash计算出索引位置不为空</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">      	<span class="comment">//检查第一个节点的hash和key是否和传进来的相等，相等则直接返回第一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">      	<span class="comment">//如果第一个节点的next不为空，向下遍历</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">          	<span class="comment">//如果是红黑树节点调用红黑树查找节点方法getTreeNode</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">//向下遍历链表，如果找到和传进来key和hash相等的节点直接返回</span></span><br><span class="line">          	<span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>先检查<code>table</code>是否为空，长度是否大于0。</li>
<li>使用<code>table.length - 1</code>和<code>hash</code>值进行位与运算，得出在<code>table</code>上具体位置，将该索引位置的节点赋值给<code>first</code>节点，检查该索引位置是否为空。</li>
<li>检查<code>first</code>节点的<code>hash</code>值和<code>key</code>是否和入参的一样，如果一样则<code>first</code>为目标节点，直接返回<code>first</code>节点。</li>
<li>如果<code>first</code>下一节点不为空，先判断<code>first</code>节点是否是红黑树节点，是则调用<code>getTreeNode</code>查找节点，否则遍历普通链表节点查找。</li>
<li>如果为找到直接返回<code>null</code>。</li>
</ol>
<h2 id="put"><a href="#put" class="headerlink" title="put"></a>put</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>调用<code>putVal</code>方法，参数的第一个布尔值：<code>true</code>代表如果找到节点不替换值，并返回老值，节点为<code>null</code>时还是会替换，<code>false</code>代表找到节点会用新值替换老值，并返回老值；第二个是给<code>LinkedHashMap</code>使用，这里不多介绍。</p>
<h2 id="putVal"><a href="#putVal" class="headerlink" title="putVal"></a>putVal</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">  	<span class="comment">//如果table为null或者长度为0就调用resize方法初始化table</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">  	<span class="comment">//通过hash计算索引位置，如果table表该索引位置节点为空则新增一个节点放在该位置上</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) <span class="comment">//将索引位置头节点赋值给p</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">//table表该索引位置不为空</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">      	<span class="comment">//判断p节点hash值和key值是否和传进来的hash值和key值相等</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p; <span class="comment">//如果相等则p即为要查找的目标节点，赋值给e</span></span><br><span class="line">      	<span class="comment">//判断p是否为TreeNode节点，如果是则调用putTreeVal方法查找目标节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">//走到这代表普通链表节点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123; <span class="comment">//遍历此链表，binCount用于统计节点数</span></span><br><span class="line">                <span class="comment">//p.next为空不存在目标节点，则新增一个节点插入链表尾部</span></span><br><span class="line">              	<span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                  	<span class="comment">//计算节点是否超过8个减1是因为从循环p节点的下一个节点开始的</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);<span class="comment">//调用treeifBin方法将该链表转为红黑树</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">              	<span class="comment">//e节点的hash值和key值都与传入的相等，则e即为目标节点，跳出循环</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e; <span class="comment">//将p指向下一节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">//e不为空代表找到了目标节点，将该节点的value覆盖返回oldValue</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e); <span class="comment">//用于LinkedHashMap</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold) <span class="comment">//插入节点后超过阈值则进行扩容</span></span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict); <span class="comment">//用于LinkedHashMap</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>检查<code>table</code>是否为空或者<code>length</code>等于0，如果是则调用<code>resieze</code>方法进行初始化。</li>
<li>通过<code>hash</code>值计算索引位置，将该索引位置的头节点赋值给p节点，如果该索引位置节点为空则使用传入的参数新增一个节点并放在该索引位置。</li>
<li>判断p节点的<code>key</code>和<code>hash</code>值是否跟传入的相等，如果相等，则p节点即为要查找的目标节点，将p节点赋值给e节点。</li>
<li>如果p节点不是目标节点，则判断p节点是否为<code>TreeNode</code>，如果是则调用<code>putTreeVal</code>方法查找目标节点。</li>
<li>p为普通链表节点，则调用普通链表的方法进行查找，并定于变量<code>binCount</code>来统计链表的节点数。</li>
<li>如果p的<code>next</code>节点为空时，则代表找不到目标节点，则新增一个节点插入链表尾部，并检查链表节点数是否超过8个，如果超过则调用<code>treeifyBin</code>将链表转成红黑树。</li>
<li>如果遍历的e节点存在<code>hash</code>值和<code>key</code>值都与传入的相同，则e节点即为目标节点，跳出循环。</li>
<li>如果e节点不为空，则代表目标节点存在，使用传入的<code>value</code>覆盖该节点的<code>value</code>，并返回<code>oldValue</code>。</li>
<li>如果插入节点后节点数超过阈值，则调用<code>resize</code>方法进行扩容。</li>
</ol>
<p>##resize</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123; <span class="comment">//老table不为空</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123; <span class="comment">//老table容量超过最大容量</span></span><br><span class="line">            threshold = Integer.MAX_VALUE; <span class="comment">//设置阈值为Integer.MAX_VALUE</span></span><br><span class="line">            <span class="keyword">return</span> oldTab;					</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">//老table容量*2小于最大容量并且老table容量大于等于默认容量16，则将新阈值设置为原来的2倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">//老表的容量为0, 老表的阈值大于0, 是因为初始容量被放入阈值</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr; <span class="comment">//将新表的容量设置为老表的阈值</span></span><br><span class="line">  	<span class="comment">//老表的容量为0, 老表的阈值为0, 则为空表，设置默认容量和阈值</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">//新阈值为0，则通过新长度*负载因子获得新阈值</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr; <span class="comment">//将当前阈值设置为刚计算出来的阈值</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">  	<span class="comment">//定义新表，容量为刚计算出的新容量</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap]; </span><br><span class="line">    table = newTab; <span class="comment">//将新表赋值为当前表</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123; <span class="comment">//老表不为空, 则需遍历将节点赋值给新表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123; <span class="comment">//将索引值为j的头节点赋值给e</span></span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>; <span class="comment">//将老表的节点设置为空，方便垃圾回收器回收</span></span><br><span class="line">              	<span class="comment">//如果e.next为空，代表只有一个节点</span></span><br><span class="line">              	<span class="comment">//通过hash计算出新表的索引位置，直接将该节点放在该位置上</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>) </span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">              	<span class="comment">//如果e是红黑树节点就调用调用treeNode的hash分布</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;<span class="comment">//存储跟原索引位置相同的节点</span></span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;<span class="comment">//存储跟原索引位置不同的节点</span></span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next; <span class="comment">//将e的下一个节点赋值给next</span></span><br><span class="line">                      	<span class="comment">//如果e的hash值与老表的容量进行与运算为0，则扩容后的位置跟老表的位置一样</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>) <span class="comment">//代表该节点是第一个节点</span></span><br><span class="line">                                loHead = e; <span class="comment">//将loHead赋值为第一个节点</span></span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e; <span class="comment">//否则将节点添加在loTail后面</span></span><br><span class="line">                            loTail = e; <span class="comment">//将loTail设置为新增节点</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    <span class="comment">//如果e的hash值与老表的容量进行与运算为1，则新的位置为：老表的索引位置+oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>) <span class="comment">//如果hiTail为空，代表该节点是第一个节点</span></span><br><span class="line">                                hiHead = e; <span class="comment">//将hiHead赋值为第一个节点</span></span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e; <span class="comment">//否则将节点添加在hiTail后面</span></span><br><span class="line">                            hiTail = e; <span class="comment">//将hiTail设置新增节点</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>; <span class="comment">//最后一个节点的next设置为空</span></span><br><span class="line">                        newTab[j] = loHead; <span class="comment">//将原索引位置的节点设置为对应的头节点</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>; <span class="comment">//最后一个节点的next设置为空</span></span><br><span class="line">                      	<span class="comment">//将索引位置j+oldCap的节点设置为对应的头节点</span></span><br><span class="line">                        newTab[j + oldCap] = hiHead; </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>如果老表的容量大于0，判断老表的容量是否超过最大容量值：如果超过则将阈值设置为<code>Integer.MAX_VALUE</code>,并直接返回老表（此时<code>oldCap * 2</code>比<code>Integer.MAX_VALUE</code>大，因此无法进行重新分布，只是单纯的将阈值扩容到最大）；如果老容量*2小于最大容量并且老容量大于等于默认容量16，就将新的阈值设置为老阈值的2倍。</li>
<li>如果老表的容量为0，老表的阈值大于0，这种情况是穿了容量的<code>new</code>方法创建的空表，将新表的阈值设置为老表的阈值（这种情况发生在新创建的<code>HashMap</code>第一次<code>put</code>时，该<code>HashMap</code>初始化的时候传了初始容量，由于<code>HashMap</code>并没有<code>capacity</code>变量来存放容量值，因此传进来的初始容量时存放在<code>threshold</code>变量上），因此此时来表<code>threshold</code>的值就是我们要创建的<code>HashMap</code>的<code>capacity</code>，所以将新表的容量设置为老表的阈值。</li>
<li>如果老表的容量为0，老表的阈值为0，这种情况是没有传容量的new方法创建的空表，将阈值和容量设置为默认值。</li>
<li>如果新表的阈值为空，则通过新的容量*负载因子获得阈值（这种情况时初始化的时候传了初始容量，跟第2点相同情况，或者初始容量设置的太小导致老表的容量没有超过16导致的）。</li>
<li>将当前阈值设置刚计算出来的新的阈值，定义新表，容量为刚计算出来的新容量，将当前的表设置为新定义的表。</li>
<li>如果老表不为空，则需遍历所有节点，将节点赋值给新表。</li>
<li>将老表上索引为j的头节点赋值给e，并将老表上索引为j的节点设置为空。</li>
<li>如果e的<code>next</code>节点为空，则代表老表的该位置只有1个节点，通过<code>hash</code>值计算新表的位置，直接将该节点放在新表的位置上。</li>
<li>如果e的<code>next</code>节点不为空，并且e为<code>TreeNode</code>，则调用<code>split</code>方法进行<code>hash</code>分布。</li>
<li>如果e的<code>next</code>节点不为空，并且e为普通的链表节点，则进行普通的<code>hash</code>分布。</li>
<li>如果e的<code>hash</code>值与老表的容量（为一串只有1个为2的二进制数，例如16位0000 0000 0001 0000）进行位与运算为0，则说明e节点扩容后的索引位置跟来表的索引位置一样，进行链表拼接操作；如果<code>loTail</code>为空，代表该节点为第一个节点，则将<code>loHead</code>赋值为该节点；否则将节点添加在<code>loTail</code>后面，并将<code>loTail</code>赋值为新增的节点。</li>
<li>如果e的<code>hash</code>值与老表的容量（为一串只有1个为2的二进制数，例如16位0000 0000 0001 0000）进行位与运算为1，则说明e节点扩容后的索引位置：老表的索引位置+oldCap，进行链表拼接操作；如果<code>hiTail</code>为空，代表该节点为第一个节点，则将<code>hiHead</code>赋值为该节点；否则将节点添加在<code>hiTail</code>后面，并将<code>hiTail</code>赋值为新增的节点。</li>
<li>老表节点重新<code>hash</code>分布在新表结束后，如果<code>loTail</code>不为空（说明老表的数据有分布到新表上原索引位置的节点），则将最后一个节点的<code>next</code>设为空，并将新表上原索引位置的节点设置为对应的头节点；如果<code>hiTail</code>不为空（说明老表的数据有分布到新表上原索引+oldCap位置的节点），则将最后一个节点的<code>next</code>设为空，并将新表上索引位置为原索引+oldCap的节点设置为对应的头节点。</li>
<li>返回新表。</li>
</ol>
<h2 id="putAll"><a href="#putAll" class="headerlink" title="putAll"></a>putAll</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">      putMapEntries(m, <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>调用<code>putMapEntries</code>方法</p>
<h2 id="putMapEntries"><a href="#putMapEntries" class="headerlink" title="putMapEntries"></a>putMapEntries</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      	<span class="comment">//如果还未添加过任何元素，算出传进来Map的容量长度，如果该长度大于阈值，就根据该长度重新计算阈值</span></span><br><span class="line">        <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">            <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">            <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold) <span class="comment">//如果传进来的Map size大于扩容阈值，就调用扩容方法resize</span></span><br><span class="line">            resize();</span><br><span class="line">      	<span class="comment">//循环传进来的Map，调用putVal方法将元素一一添加进table</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">            K key = e.getKey();</span><br><span class="line">            V value = e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用<code>removeNode</code>方法传入<code>key</code>和<code>key</code>的<code>hash</code>值，如果为<code>null</code>直接返回<code>null</code>否则返回节点的<code>value</code>值。</p>
<h2 id="removeNode"><a href="#removeNode" class="headerlink" title="removeNode"></a>removeNode</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">  			<span class="comment">//table不为空，table长度大于0，table通过hash计算索引位置的头节点不为空</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">          	<span class="comment">//判断头节点是否就是要删除的节点</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                node = p;</span><br><span class="line">          	<span class="comment">//如果第一个节点的next不为空，向下遍历</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">              	<span class="comment">//判断是否是红黑树节点，如果是调用getTreeNode寻找节点</span></span><br><span class="line">                <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">//普通链表节点</span></span><br><span class="line">                  	<span class="comment">//循环普通连接节点，寻找hash和key与传参相等的节点</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                            ((k = e.key) == key ||</span><br><span class="line">                             (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                            node = e;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        p = e;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          	<span class="comment">//寻找到目标节点</span></span><br><span class="line">            <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                                 (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">              	<span class="comment">//判断节点是否是红黑树节点，如果是调用removeTreeNode方法删除节点</span></span><br><span class="line">                <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">              	<span class="comment">//判断头节点是否就是寻找的节点，如果是，直接将node节点的next节点放在索引位置上</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                    tab[index] = node.next;</span><br><span class="line">                <span class="keyword">else</span> <span class="comment">//走到这代表是普通链表节点，直接将头节点的next指针指向要删除节点的下一节点</span></span><br><span class="line">                    p.next = node.next;</span><br><span class="line">                ++modCount;</span><br><span class="line">                --size;</span><br><span class="line">                afterNodeRemoval(node); <span class="comment">//用于LinkedHashMap</span></span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>判断<code>table</code>不为空，<code>table</code>长度大于0，<code>table</code>通过<code>hash</code>计算索引位置的头节点不为空，否则直接返回<code>null</code>。</li>
<li>判断头节点是否就是要删除的节点，如果是将p节点赋值给<code>node</code>节点。</li>
<li>头节点不是要要删除节点，判断p节点是否是<code>TreeNode</code>节点，如果是调用<code>getTreeNode</code>方法寻找对应节点。</li>
<li>p为普通链表节点，则调用普通链表的方法遍历进行查找对应节点。</li>
<li>如果寻找到目标节点，判断是否是<code>TreeNode</code>节点，如果是调用<code>removeTreeNode</code>方法删除节点；不是<code>TreeNode</code>节点，判断要寻找的节点是否是头节点，如果是直接将p节点的next节点放在索引位置上；否则为普通链表节点，直接将p节点的next指针指向要删除节点的下一节点。</li>
</ol>
<h2 id="红黑树（TreeNode）相关方法"><a href="#红黑树（TreeNode）相关方法" class="headerlink" title="红黑树（TreeNode）相关方法"></a>红黑树（TreeNode）相关方法</h2><h2 id="getTreeNode"><a href="#getTreeNode" class="headerlink" title="getTreeNode"></a>getTreeNode</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">getTreeNode</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ((parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>).find(h, k, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用根节点调用<code>find</code>方法。</p>
<h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><ul>
<li><p>从调用此方法的节点开始查找，通过hash值和key找到对应的节点。</p>
</li>
<li><p>此处是红黑树的遍历，红黑树是特殊的自平衡二叉查找树。</p>
</li>
<li><p>平衡二叉数的特点：左节点 &lt; 根节点 &lt; 右节点。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;</span><br><span class="line">				<span class="comment">//将p节点赋值为调用此方法的节点，即为红黑树根节点</span></span><br><span class="line">         TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>;</span><br><span class="line">				<span class="comment">//从p节点开始向下遍历</span></span><br><span class="line">         <span class="keyword">do</span> &#123;</span><br><span class="line">             <span class="keyword">int</span> ph, dir; K pk;</span><br><span class="line">             TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;</span><br><span class="line">           	<span class="comment">//如果传入的hash值小于p节点的hash值，则往p节点的左边遍历</span></span><br><span class="line">             <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                 p = pl;</span><br><span class="line">           	<span class="comment">//如果传入的hash值大于p节点的hash值，则往p节点的右边遍历</span></span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                 p = pr;</span><br><span class="line">           	<span class="comment">//如果传入的hash值和key之等于p节点的hash值和key值，则p节点为目标节点，返回p节点</span></span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                 <span class="keyword">return</span> p;</span><br><span class="line">           	<span class="comment">//如果p节点的左节点为空，则向右遍历</span></span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="keyword">null</span>)</span><br><span class="line">                 p = pr;</span><br><span class="line">           	<span class="comment">//如果p节点的右节点为空，则向左遍历</span></span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="keyword">null</span>)</span><br><span class="line">                 p = pl;</span><br><span class="line">           	<span class="comment">//将p节点与k进行比较</span></span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="keyword">null</span> ||</span><br><span class="line">                       <span class="comment">//kc不为空代表k实现了Comparable</span></span><br><span class="line">                       (kc = comparableClassFor(k)) != <span class="keyword">null</span>) &amp;&amp; </span><br><span class="line">                      	<span class="comment">//k &lt; pk则dir &lt; 0，k &gt; pk则dir &gt; 0</span></span><br><span class="line">                      (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>)</span><br><span class="line">               	<span class="comment">//dir 小于0向左遍历，否则向右遍历</span></span><br><span class="line">                 p = (dir &lt; <span class="number">0</span>) ? pl : pr;</span><br><span class="line">           	<span class="comment">//代码走到此处，代表key所属类没有实现Comparable，直接指向p的右边遍历</span></span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.find(h, k, kc)) != <span class="keyword">null</span>)</span><br><span class="line">                 <span class="keyword">return</span> q;</span><br><span class="line">           	<span class="comment">//代码走到此处代表 pr.find(h, k, kc) 为空，因此直接向左遍历</span></span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">                 p = pl;</span><br><span class="line">         &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>将p节点赋值为调用此方法的节点，即为红黑树根节点。</li>
<li>从p节点开始向下遍历。</li>
<li>如果传入的<code>hash</code>值小于p节点的<code>hash</code>值，则往p节点的右边遍历。</li>
<li>如果传入的<code>hash</code>值大于p节点的<code>hash</code>值，则往p节点的右边遍历。</li>
<li>如果传入的<code>hash</code>和<code>key</code>值等于p节点的<code>hash</code>值和<code>key</code>值，则p节点为目标节点，返回p节点。</li>
<li>如果p节点的左节点为空，则向右遍历。</li>
<li>如果p节点的右节点为空，则向左遍历。</li>
<li>将p节点与k进行比较。如果传入的<code>key</code>所属的类实现了<code>Comparable</code>接口，则将k跟p节点的<code>key</code>进行比较（kc实现了<code>Comparable</code>接口，因此通过kc的比较方法进行比较），并将比较结果赋值给<code>dir</code>，如果<code>dir &lt; 0</code>则代表<code>k &lt; pk</code>，则向p节点的左边遍历（pl）；否则，向p节点的右边遍历（pr）。</li>
<li><code>key</code>所属类没有实现<code>Comparable</code>接口，因此直接向右遍历。</li>
<li><code>pr.find(h, k, kc)</code>为空，因此直接向左遍历。</li>
</ol>
<h2 id="putTreeVal"><a href="#putTreeVal" class="headerlink" title="putTreeVal"></a>putTreeVal</h2><p>红黑树的put操作，红黑树插入会同时维护原来的链表属性，即原来的next属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">         Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">boolean</span> searched = <span class="keyword">false</span>;</span><br><span class="line">				<span class="comment">//查找根节点，索引的头节点并不一定为红黑树根节点</span></span><br><span class="line">         TreeNode&lt;K,V&gt; root = (parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>;</span><br><span class="line">				<span class="comment">//将根节点赋值给p节点，开始进行查找</span></span><br><span class="line">         <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">             <span class="keyword">int</span> dir, ph; K pk;</span><br><span class="line">           	<span class="comment">//传入的hash值小于p节点的hash值，向p的左边查找树</span></span><br><span class="line">             <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                 dir = -<span class="number">1</span>;</span><br><span class="line">           	<span class="comment">//传入的hash值大于p节点的hash值，向p的右边查找树</span></span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                 dir = <span class="number">1</span>;</span><br><span class="line">           	<span class="comment">//如果传入的hash值和key值等于p节点的hash值和key值，则p节点为目标节点，返回p节点</span></span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                 <span class="keyword">return</span> p;</span><br><span class="line">           	<span class="comment">//如果所属的类没有实现Comparable接口 或者 k和p节点的key相等</span></span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                       (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                      (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">               	<span class="comment">//第一次符合条件，从p节点的左节点和右节点分别调用find方法进行查找，如果找到就返回</span></span><br><span class="line">                 <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                     TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                     searched = <span class="keyword">true</span>;</span><br><span class="line">                     <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                          (q = ch.find(h, k, kc)) != <span class="keyword">null</span>) ||</span><br><span class="line">                         ((ch = p.right) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                          (q = ch.find(h, k, kc)) != <span class="keyword">null</span>))</span><br><span class="line">                         <span class="keyword">return</span> q;</span><br><span class="line">                 &#125;</span><br><span class="line">               	<span class="comment">//使用定义的一套规则来比较k和p节点的key的大小，用来决定向左还是向右查找</span></span><br><span class="line">                 dir = tieBreakOrder(k, pk);<span class="comment">//dir&lt;0则代表k&lt;pk，则向p左边查找；反之亦然</span></span><br><span class="line">             &#125;</span><br><span class="line">					<span class="comment">//xp赋值为x的父节点，中间变量，用于下面给x的父节点赋值</span></span><br><span class="line">             TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">           	<span class="comment">//dir&lt;=0则向p左边查找，否则向p右边查找，如果为null，则代表该位置即为x的目标位置</span></span><br><span class="line">             <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">               	<span class="comment">//走进来代表以及找到x的位置，只需将x放到该位置即可</span></span><br><span class="line">                 Node&lt;K,V&gt; xpn = xp.next; </span><br><span class="line">               	<span class="comment">//创建新的节点，其中x的next节点为xpn，即将x节点插入xp与xpn之间</span></span><br><span class="line">                 TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">               	<span class="comment">//调整x、xp、xpn之间的属性关系</span></span><br><span class="line">                 <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                     xp.left = x; <span class="comment">//代表x节点为xp的左节点</span></span><br><span class="line">                 <span class="keyword">else</span></span><br><span class="line">                     xp.right = x; <span class="comment">//代表x节点为xp的右节点</span></span><br><span class="line">                 xp.next = x; <span class="comment">//将xp的next节点设置为x</span></span><br><span class="line">                 x.parent = x.prev = xp; <span class="comment">//将x的parent和prev节点设置为xp</span></span><br><span class="line">               	<span class="comment">//如果xpn不为空，则将xpn的prev节点设置为x节点，与上文的x节点的next节点对应</span></span><br><span class="line">                 <span class="keyword">if</span> (xpn != <span class="keyword">null</span>) </span><br><span class="line">                     ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">               	<span class="comment">//进行红黑树的插入平衡调整</span></span><br><span class="line">                 moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>查找根节点，索引位置的头节点不一定为红黑树的根节点。</li>
<li>将根节点赋值给p节点，开始进行查找。</li>
<li>如果传入的<code>hash</code>值小于p节点的<code>hash</code>值，将<code>dir</code>赋值为-1，代表向p的左边查找树。</li>
<li>如果传入的<code>hash</code>值大于p节点的<code>hash</code>值，将<code>dir</code>赋值为1，代表向p的右边查找树。</li>
<li>如果传入的<code>hash</code>值和<code>key</code>值等于p节点的<code>hash</code>值和<code>key</code>值，则p节点即为目标节点，返回p节点。</li>
<li>如果k所属的类型没有实现<code>Comparable</code>接口 或者 k和p节点的<code>key</code>相等；如果<code>searched</code>为<code>false</code>，从p节点的左节点和右节点分别调用<code>find</code>方法进行查找，如果查找到目标节点则返回；否则使用定义的一套规则来比较k和p节点的<code>key</code>的大小，用来决定向左还是向右查找。</li>
<li><code>dir &lt; 0</code>则向p左边查找，否则向p右边查找，如果为<code>null</code>，则代表该位置即为x的目标位置。</li>
<li>创建新的节点，其中x的<code>next</code>节点为<code>xpn</code>，即将x节点插入<code>xp</code>与<code>xpn</code>之间。</li>
<li>调整x、xp、xpn之间的属性关系。</li>
<li>进行红黑树的插入平衡调整。</li>
</ol>
<h2 id="tieBreakOrder"><a href="#tieBreakOrder" class="headerlink" title="tieBreakOrder"></a>tieBreakOrder</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tieBreakOrder</span><span class="params">(Object a, Object b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span> || b == <span class="keyword">null</span> ||</span><br><span class="line">        (d = a.getClass().getName().</span><br><span class="line">         compareTo(b.getClass().getName())) == <span class="number">0</span>)</span><br><span class="line">        d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ?</span><br><span class="line">             -<span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用于不可比较或者<code>hashCode</code>相同时进行比较的方法，只是一个一直的插入规则，用来维护定位的等价性。</p>
<h2 id="treeifyBin"><a href="#treeifyBin" class="headerlink" title="treeifyBin"></a>treeifyBin</h2><p>将链表节点转换为红黑树节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">		<span class="comment">//如果table为空或者table的长度小于64，调用resize方法进行扩容</span></span><br><span class="line">     <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">         resize();</span><br><span class="line">		<span class="comment">//根据hash值计算索引值，将该索引位置的节点赋值给e，从e开始遍历该索引位置的链表</span></span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">         TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">do</span> &#123;</span><br><span class="line">           	<span class="comment">//将链表节点转红黑树节点</span></span><br><span class="line">             TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">           	<span class="comment">//如果是第一次遍历，将头节点赋值给hd</span></span><br><span class="line">             <span class="keyword">if</span> (tl == <span class="keyword">null</span>) <span class="comment">//t1为空代表为第一次循环</span></span><br><span class="line">                 hd = p;</span><br><span class="line">             <span class="keyword">else</span> &#123; <span class="comment">//如果不是第一次遍历，则处理当前节点的prev属性和上一节点的next属性</span></span><br><span class="line">                 p.prev = tl; <span class="comment">//当前节点的prev属性设为上一节点</span></span><br><span class="line">                 tl.next = p; <span class="comment">//上一节点的next属性设置为当前节点</span></span><br><span class="line">             &#125;</span><br><span class="line"> <span class="comment">//将p节点赋值给t1，用于在下一次循环中作为上一节点进行一些链表的关联操作(p.prev = t1 和 t1.next = p)</span></span><br><span class="line">             tl = p;</span><br><span class="line">         &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">   <span class="comment">//将table该索引位置赋值为新转的TreeNode头节点，如果该节点不为空，则以头节点(hd)为根节点，构建红黑树</span></span><br><span class="line">         <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">             hd.treeify(tab);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>如果<code>table</code>为空或者<code>table</code>的长度小于64，调用<code>resize</code>方法进行扩容。</li>
<li>根据<code>hash</code>值j计算索引值，将该索引值位置的节点赋值给e，从e开始遍历该索引位置的链表。</li>
<li>将链表节点转红黑树节点。</li>
<li>如果是第一次遍历，将头节点赋值给hd。</li>
<li>如果不是第一次遍历，则处理当前节点的<code>prev</code>属性和上一节点的<code>next</code>属性。</li>
<li>将p节点赋值给t1，用于在下一次循环中作为上一节点进行一些链表的关联操作(p.prev = t1 和 t1.next = p)。</li>
<li>将<code>table</code>该索引位置赋值新转的<code>TreeNode</code>的头节点，如果该节点不为空，则以头节点(hd)为根节点，构建红黑树。</li>
</ol>
<h2 id="treeify"><a href="#treeify" class="headerlink" title="treeify"></a>treeify</h2><p>构建红黑树。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;</span><br><span class="line">         TreeNode&lt;K,V&gt; root = <span class="keyword">null</span>;</span><br><span class="line">				<span class="comment">//将调用此方法的节点赋值给x，以x作为起点，开始进行遍历</span></span><br><span class="line">         <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="keyword">this</span>, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">             next = (TreeNode&lt;K,V&gt;)x.next;<span class="comment">//next赋值为x的下个节点</span></span><br><span class="line">             x.left = x.right = <span class="keyword">null</span>;<span class="comment">//将x的左右节点设置为空</span></span><br><span class="line">             <span class="comment">//如果还没有根节点，则将x设置为根节点</span></span><br><span class="line">           	<span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">                 x.parent = <span class="keyword">null</span>; <span class="comment">//根节点没有父节点</span></span><br><span class="line">                 x.red = <span class="keyword">false</span>; <span class="comment">//根节点必须为黑色</span></span><br><span class="line">                 root = x; <span class="comment">//将x设置为根节点</span></span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">else</span> &#123;</span><br><span class="line">                 K k = x.key; <span class="comment">//k赋值为x的key</span></span><br><span class="line">                 <span class="keyword">int</span> h = x.hash; <span class="comment">//h赋值为x的hash值</span></span><br><span class="line">                 Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">               	<span class="comment">//如果当前节点x不是根节点，则从根节点开始查找属于该节点的位置</span></span><br><span class="line">                 <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                     <span class="keyword">int</span> dir, ph;</span><br><span class="line">                     K pk = p.key;</span><br><span class="line">                   	<span class="comment">//如果x节点的hash值小于p节点的hash值，则将dir赋值为-1，代表向p的左边查找</span></span><br><span class="line">                     <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                         dir = -<span class="number">1</span>;</span><br><span class="line">                   	<span class="comment">//如果x节点的hash值大于p节点的hash值，则将dir赋值为1，代表向p的右边查找</span></span><br><span class="line">                     <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                         dir = <span class="number">1</span>;</span><br><span class="line">                   	<span class="comment">//走到这代表x的hash值和p的hash值相等，则比较key值</span></span><br><span class="line">                     <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                               <span class="comment">//如果k没有实现Comparable接口 或者 x节点的key和p节点的key相等</span></span><br><span class="line">                               (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                              (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                       	<span class="comment">//使用定义的一套规则来比较x节点和p节点的大小，用来决定向左还是向右</span></span><br><span class="line">                         dir = tieBreakOrder(k, pk);</span><br><span class="line">									<span class="comment">//xp赋值为x的父节点，中间变量用于下面给x的父节点赋值</span></span><br><span class="line">                     TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                   	<span class="comment">//dir&lt;=0则向p左边查找，否则向p右边查找，如果为null，则代表该位置即为x的目标位置</span></span><br><span class="line">                     <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                       	<span class="comment">//x和xp节点的属性设置</span></span><br><span class="line">                         x.parent = xp; <span class="comment">//x的父节点即为最后一次遍历的p节点</span></span><br><span class="line">                         <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>) <span class="comment">//如果是dir &lt; 0，则代表x节点为父节点的左节点</span></span><br><span class="line">                             xp.left = x;</span><br><span class="line">                         <span class="keyword">else</span> <span class="comment">//如果是dir &gt; 0，则代表x节点为父节点的右节点</span></span><br><span class="line">                             xp.right = x;</span><br><span class="line">                       	<span class="comment">//进行红黑树的插入平衡</span></span><br><span class="line">                         root = balanceInsertion(root, x);</span><br><span class="line">                         <span class="keyword">break</span>;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">				<span class="comment">//如果root节点不再table索引位置的头节点，则将其调整为头节点</span></span><br><span class="line">         moveRootToFront(tab, root);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>将调用此方法的节点赋值给x，以x作为起点，开始进行遍历。</li>
<li>如果还没有根节点，则将x设置为根节点。</li>
<li>如果当前节点x不是根节点，则从根节点开始查找属于该节点的位置。</li>
<li>如果x节点的<code>hash</code>值小于p节点的<code>hash</code>值，则将<code>dir</code>赋值为-1，代表向p的左边查找。</li>
<li>如果x节点的<code>hash</code>值大于p节点的<code>hash</code>值，则将<code>dir</code>赋值为1，代表向p的右边查找。</li>
<li>走到这代表x的<code>hash</code>值和p的<code>hash</code>值相等，则比较<code>key</code>值。</li>
<li><code>dir &lt;= 0</code>则向p左边查找，否则向p右边查找，如果为<code>null</code>，则代表该位置即为x的目标位置。</li>
<li>x和xp节点的属性设置。</li>
<li>进行红黑树的插入平衡（通过左旋、右旋和改变节点颜色来保证当前数符合红黑树要求）。</li>
<li>如果<code>root</code>节点不再<code>table</code>索引位置的头节点，则将其调整为头节点。</li>
</ol>
<h2 id="moveRootToFront"><a href="#moveRootToFront" class="headerlink" title="moveRootToFront"></a>moveRootToFront</h2><p>将root放到头节点的位置，如果当前索引位置的头节点不是root节点，则将root的上一节点和下一节点进行关联，将root放到头节点的位置，原头节点放在root的next节点上。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">moveRootToFront</span><span class="params">(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> n;</span><br><span class="line">				<span class="comment">//检查root是否为空，table是否为空，table的length是否大于0</span></span><br><span class="line">         <span class="keyword">if</span> (root != <span class="keyword">null</span> &amp;&amp; tab != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           	<span class="comment">//计算root节点的索引位置</span></span><br><span class="line">             <span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; root.hash;</span><br><span class="line">             TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index];</span><br><span class="line">           	<span class="comment">//如果该索引位置的头节点不是root节点，则该索引位置的头节点替换为root节点</span></span><br><span class="line">             <span class="keyword">if</span> (root != first) &#123;</span><br><span class="line">                 Node&lt;K,V&gt; rn;</span><br><span class="line">               	<span class="comment">//将该索引位置的头节点赋值为root节点</span></span><br><span class="line">                 tab[index] = root;</span><br><span class="line">                 TreeNode&lt;K,V&gt; rp = root.prev; <span class="comment">//root节点的上一个节点</span></span><br><span class="line">           <span class="comment">//如果root节点的next节点不为空，则将root节点的next节点的prev属性设置为root节点的prev节点</span></span><br><span class="line">                 <span class="keyword">if</span> ((rn = root.next) != <span class="keyword">null</span>)</span><br><span class="line">                     ((TreeNode&lt;K,V&gt;)rn).prev = rp;</span><br><span class="line">           <span class="comment">//如果root节点的next节点不为空，则将root节点的prev节点的next属性设置为root节点的next节点</span></span><br><span class="line">                 <span class="keyword">if</span> (rp != <span class="keyword">null</span>)</span><br><span class="line">                     rp.next = rn;</span><br><span class="line">                 <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">                     first.prev = root;</span><br><span class="line">               	<span class="comment">//将root节点的next属性设置为原头节点</span></span><br><span class="line">                 root.next = first;</span><br><span class="line">               	<span class="comment">//root此时已经被放到该位置头节点位置，因此将prev属性设为空</span></span><br><span class="line">                 root.prev = <span class="keyword">null</span>;</span><br><span class="line">             &#125;</span><br><span class="line">           	<span class="comment">//检查树是否正常</span></span><br><span class="line">             <span class="function"><span class="keyword">assert</span> <span class="title">checkInvariants</span><span class="params">(root)</span></span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>检查root是否为空，table是否为空，table的length是否大于0。</li>
<li>计算root节点的索引位置。</li>
<li>如果该索引位置的头节点不是root节点，则该索引位置的头节点替换为root节点。</li>
<li>检查树是否正常。</li>
</ol>
<h2 id="checkInvariants"><a href="#checkInvariants" class="headerlink" title="checkInvariants"></a>checkInvariants</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">checkInvariants</span><span class="params">(TreeNode&lt;K,V&gt; t)</span> </span>&#123;<span class="comment">//一些基本的检查</span></span><br><span class="line">    TreeNode&lt;K,V&gt; tp = t.parent, tl = t.left, tr = t.right,</span><br><span class="line">        tb = t.prev, tn = (TreeNode&lt;K,V&gt;)t.next;</span><br><span class="line">    <span class="keyword">if</span> (tb != <span class="keyword">null</span> &amp;&amp; tb.next != t)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (tn != <span class="keyword">null</span> &amp;&amp; tn.prev != t)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (tp != <span class="keyword">null</span> &amp;&amp; t != tp.left &amp;&amp; t != tp.right)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (tl != <span class="keyword">null</span> &amp;&amp; (tl.parent != t || tl.hash &gt; t.hash))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (tr != <span class="keyword">null</span> &amp;&amp; (tr.parent != t || tr.hash &lt; t.hash))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  	<span class="comment">//如果当前节点为红色，则该节点的左右节点都不能为红色</span></span><br><span class="line">    <span class="keyword">if</span> (t.red &amp;&amp; tl != <span class="keyword">null</span> &amp;&amp; tl.red &amp;&amp; tr != <span class="keyword">null</span> &amp;&amp; tr.red)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (tl != <span class="keyword">null</span> &amp;&amp; !checkInvariants(tl))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (tr != <span class="keyword">null</span> &amp;&amp; !checkInvariants(tr))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将传入的节点作为根节点，遍历所有节点，检查节点的合法性，主要是保证树符合红黑树的规则。</p>
<h2 id="split"><a href="#split" class="headerlink" title="split"></a>split</h2><p>扩容后，红黑树的hash分布，只可能存在于两个位置：原索引位置、原索引位置 + oldCap。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index, <span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; b = <span class="keyword">this</span>;<span class="comment">//拿到调用此方法的节点</span></span><br><span class="line">        <span class="comment">// Relink into lo and hi lists, preserving order</span></span><br><span class="line">        TreeNode&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;<span class="comment">//存储索引位置为:“原索引位置”的节点</span></span><br><span class="line">        TreeNode&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;<span class="comment">//存储索引位置为:“原索引位置+oldCap”的节点</span></span><br><span class="line">        <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">			<span class="comment">//以调用此方法的节点开始，遍历整个红黑树节点</span></span><br><span class="line">        <span class="keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="keyword">null</span>; e = next) &#123;<span class="comment">//从b节点开始遍历</span></span><br><span class="line">            next = (TreeNode&lt;K,V&gt;)e.next;<span class="comment">//next赋值为e的下个节点</span></span><br><span class="line">            e.next = <span class="keyword">null</span>;<span class="comment">//同时将老表的节点设置为空，以便垃圾收集器回收</span></span><br><span class="line">          	<span class="comment">//如果e的hash值与老表的容量进行与运算为0，则扩容后的索引位置跟老表的索引位置一样</span></span><br><span class="line">            <span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e.prev = loTail) == <span class="keyword">null</span>)<span class="comment">//如果loTail为空，代表该该节点为第一个节点</span></span><br><span class="line">                    loHead = e;<span class="comment">//则将loHead赋值为第一个节点</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    loTail.next = e;<span class="comment">//否则将节点添加在loTail后面</span></span><br><span class="line">                loTail = e;<span class="comment">//并将loTail赋值为新增的节点</span></span><br><span class="line">                ++lc; <span class="comment">//统计原索引位置的节点个数</span></span><br><span class="line">            &#125;</span><br><span class="line">          	<span class="comment">//如果e的hash值与老表的容量进行与运算为1，则扩容后的索引位置为：老表的索引位置 + oldCap</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e.prev = hiTail) == <span class="keyword">null</span>)<span class="comment">//如果hiHead为空，代表该节点为第一个节点</span></span><br><span class="line">                    hiHead = e; <span class="comment">//则将hiHead赋值为第一个节点</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    hiTail.next = e; <span class="comment">//否则将节点添加在hiTail后面</span></span><br><span class="line">                hiTail = e; <span class="comment">//并将hiTail赋值为新增的节点</span></span><br><span class="line">                ++hc; <span class="comment">//统计索引位置为原索引 + oldCap的节点个数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//如果原索引位置的节点不为空</span></span><br><span class="line">        <span class="keyword">if</span> (loHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD) <span class="comment">//如果节点个数&lt;=6个则将红黑树转为链表结构</span></span><br><span class="line">                tab[index] = loHead.untreeify(map);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                tab[index] = loHead; <span class="comment">//将原索引位置的节点设置为对应的头节点</span></span><br><span class="line">              	<span class="comment">//如果hiHead不为空，则代表原来的红黑树已经被改变，需要重新构建新的红黑树</span></span><br><span class="line">              	<span class="comment">//老表的红黑树由于节点被分到两个位置</span></span><br><span class="line">                <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) <span class="comment">// (else is already treeified)</span></span><br><span class="line">                  	<span class="comment">//以loHead为根节点，构建新的红黑树</span></span><br><span class="line">                    loHead.treeify(tab);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">			<span class="comment">//如果索引位置为原索引+oldCap的节点不为空</span></span><br><span class="line">        <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">          	<span class="comment">//如果节点个数&lt;=6个，则将红黑树转为链表结构</span></span><br><span class="line">            <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">                tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">              	<span class="comment">//将索引位置为原索引+oldCap的节点设置为对应的头节点</span></span><br><span class="line">                tab[index + bit] = hiHead;</span><br><span class="line">              	<span class="comment">//loHead不为空则代表原来的红黑树已经被改变，需要重新构建新的红黑树</span></span><br><span class="line">                <span class="keyword">if</span> (loHead != <span class="keyword">null</span>)</span><br><span class="line">                  	<span class="comment">//以hiHead为根节点，构建新的红黑树</span></span><br><span class="line">                    hiHead.treeify(tab);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>以调用此方法的节点开始，遍历整个红黑树节点。</li>
<li>如果e的<code>hash</code>值与老表的容量进行与运算为0，则扩容后的索引位置跟老表的索引位置一样。</li>
<li>如果e的<code>hash</code>值与老表的容量进行与运算为1，则扩容后的索引位置为：老表的索引位置 <code>+ oldCap</code>。</li>
<li>如果原索引位置的节点不为空，如果节点个数小于等于6则将红黑树转为链表结构，否则将原索引位置的节点设置为对应的头节点，如果<code>hiHead</code>不为空，则代表原来的红黑树已经被改变，需要重新构建新的红黑树。</li>
<li>如果索引位置为原索引+oldCap的节点不为空，如果节点个数小于等于6则将红黑树转为链表结构，否则将原索引位置<code>+ oldCap</code>的节点设置为对应的头节点，如果<code>hiHead</code>不为空，则代表原来的红黑树已经被改变，需要重新构建新的红黑树。</li>
</ol>
<h2 id="untreeify"><a href="#untreeify" class="headerlink" title="untreeify"></a>untreeify</h2><p>将红黑树节点转为链表节点，当节点&lt;=6时会被触发。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">untreeify</span><span class="params">(HashMap&lt;K,V&gt; map)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>; <span class="comment">//hd 头节点，t1 尾节点</span></span><br><span class="line">  	<span class="comment">//从调用该方法节点，即链表的头节点开始遍历，将所有节点转换为链表节点</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt; q = <span class="keyword">this</span>; q != <span class="keyword">null</span>; q = q.next) &#123; </span><br><span class="line">        Node&lt;K,V&gt; p = map.replacementNode(q, <span class="keyword">null</span>);</span><br><span class="line">      	<span class="comment">//如果t1为null，代表是第一个节点，将hd赋值为该节点</span></span><br><span class="line">        <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">            hd = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//否则将尾节点赋值给p</span></span><br><span class="line">            tl.next = p;</span><br><span class="line">        tl = p; <span class="comment">//每次将尾节点指向当前节点，即为节点</span></span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">//返回转换后的链表的头节点 </span></span><br><span class="line">    <span class="keyword">return</span> hd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>从调用该方法节点，即链表的头节点开始遍历，将所有节点转换为链表节点。</li>
<li>调用<code>replacementNode</code>方法构建链表节点。</li>
<li>如果t1为null，代表是第一个节点，将hd赋值为该节点，否则否则将尾节点赋值给p。</li>
<li>每次将尾节点指向当前节点，即为节点。</li>
<li>返回转换后的链表的头节点 。</li>
</ol>
<h2 id="remove-1"><a href="#remove-1" class="headerlink" title="remove"></a>remove</h2><p>红黑树的节点移除。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeTreeNode</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//------链表的处理start-------</span></span><br><span class="line">      <span class="keyword">int</span> n;</span><br><span class="line">    	<span class="comment">//table为空或长度为0直接返回</span></span><br><span class="line">      <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">    	<span class="comment">//根据hash计算出索引的位置</span></span><br><span class="line">      <span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; hash;</span><br><span class="line">    	<span class="comment">//将索引位置的头节点赋值给first和root</span></span><br><span class="line">      TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index], root = first, rl;</span><br><span class="line">    	<span class="comment">//该方法将要被移除的node(TreeNode)调用，因此此方法的this为要被移除node节点</span></span><br><span class="line">    	<span class="comment">//将node的next节点赋值给succ节点，prev节点赋值给pred节点</span></span><br><span class="line">      TreeNode&lt;K,V&gt; succ = (TreeNode&lt;K,V&gt;)next, pred = prev;</span><br><span class="line">    	<span class="comment">//如果pred节点为空，则代表要被移除的node节点为头节点，将table索引位置的值和first节点的值赋值为succ节点（node的next节点）即可</span></span><br><span class="line">      <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">          tab[index] = first = succ;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        	<span class="comment">//否则将pred节点的next属性设置为succ节点（node的next节点）</span></span><br><span class="line">          pred.next = succ;</span><br><span class="line">    	<span class="comment">//如果succ节点不为空，则将succ的prev节点设置为pred，与前面对应</span></span><br><span class="line">      <span class="keyword">if</span> (succ != <span class="keyword">null</span>)</span><br><span class="line">          succ.prev = pred;</span><br><span class="line">    	<span class="comment">//如果进行到此first节点为空，则代表该索引位置已经没有节点则直接返回</span></span><br><span class="line">      <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">    	<span class="comment">//如果root的父节点不为空，则将root赋值为根节点</span></span><br><span class="line">      <span class="keyword">if</span> (root.parent != <span class="keyword">null</span>)</span><br><span class="line">          root = root.root();</span><br><span class="line">    	<span class="comment">//通过root节点来判断此红黑树是否太小，如果是则调用untreeify方法转为链表节点并返回</span></span><br><span class="line">    	<span class="comment">//转链表后就无需再进行下面的红黑树处理</span></span><br><span class="line">      <span class="keyword">if</span> (root == <span class="keyword">null</span></span><br><span class="line">          || (movable</span><br><span class="line">              &amp;&amp; (root.right == <span class="keyword">null</span></span><br><span class="line">                  || (rl = root.left) == <span class="keyword">null</span></span><br><span class="line">                  || rl.left == <span class="keyword">null</span>))) &#123;</span><br><span class="line">          tab[index] = first.untreeify(map);  <span class="comment">// too small</span></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    	<span class="comment">//-----链表的处理end-------</span></span><br><span class="line">    	<span class="comment">//-----以下代码为红黑树处理--------</span></span><br><span class="line">    	<span class="comment">//将p赋值为要被移除的node节点，p1赋值为p的左节点，pr赋值为p的右节点</span></span><br><span class="line">      TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>, pl = left, pr = right, replacement;</span><br><span class="line">    	<span class="comment">//如果p的左节点和右节点都不为空时</span></span><br><span class="line">      <span class="keyword">if</span> (pl != <span class="keyword">null</span> &amp;&amp; pr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        	<span class="comment">//将s节点赋值为p的右节点</span></span><br><span class="line">          TreeNode&lt;K,V&gt; s = pr, sl;</span><br><span class="line">        	<span class="comment">//向左一直查找，跳出循环时，s为没有左节点的节点</span></span><br><span class="line">          <span class="keyword">while</span> ((sl = s.left) != <span class="keyword">null</span>) <span class="comment">// find successor</span></span><br><span class="line">              s = sl;</span><br><span class="line">        	<span class="comment">//交换p节点和s节点的颜色</span></span><br><span class="line">          <span class="keyword">boolean</span> c = s.red; s.red = p.red; p.red = c; <span class="comment">// swap colors</span></span><br><span class="line">          TreeNode&lt;K,V&gt; sr = s.right; <span class="comment">//s的右节点</span></span><br><span class="line">          TreeNode&lt;K,V&gt; pp = p.parent; <span class="comment">//p的父节点</span></span><br><span class="line">        	<span class="comment">//---第一次调整和第二次调整：将p节点和s节点进行为位置调换---</span></span><br><span class="line">        	<span class="comment">//第一次调整</span></span><br><span class="line">        	<span class="comment">//如果p节点的右节点即为s节点，则将p的父节点赋值为s，将s的右节点赋值为p</span></span><br><span class="line">          <span class="keyword">if</span> (s == pr) &#123; <span class="comment">// p was s's direct parent</span></span><br><span class="line">              p.parent = s;</span><br><span class="line">              s.right = p;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            	<span class="comment">//将sp赋值为s的父节点</span></span><br><span class="line">              TreeNode&lt;K,V&gt; sp = s.parent;</span><br><span class="line">            	<span class="comment">//将p的父节点赋值为sp</span></span><br><span class="line">              <span class="keyword">if</span> ((p.parent = sp) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                	<span class="comment">//如果s节点为sp的左节点，则将sp的左节点赋值为p节点</span></span><br><span class="line">                  <span class="keyword">if</span> (s == sp.left)</span><br><span class="line">                      sp.left = p;</span><br><span class="line">                	<span class="comment">//否则s节点为sp的右节点，则将sp的右节点赋值为p节点</span></span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                      sp.right = p;</span><br><span class="line">              &#125;</span><br><span class="line">            	<span class="comment">//s的右节点赋值为p节点的右节点</span></span><br><span class="line">              <span class="keyword">if</span> ((s.right = pr) != <span class="keyword">null</span>)</span><br><span class="line">                	<span class="comment">//如果pr不为空，则将pr的父节点赋值为s</span></span><br><span class="line">                  pr.parent = s;</span><br><span class="line">          &#125;</span><br><span class="line">        	<span class="comment">//第二次调整</span></span><br><span class="line">        	<span class="comment">//将p的左节点赋值为空，pl已经保存了该节点</span></span><br><span class="line">          p.left = <span class="keyword">null</span>;</span><br><span class="line">        	<span class="comment">//将p节点的右节点赋值为sr，如果sr不为空，则将sr的父节点赋值为p节点</span></span><br><span class="line">          <span class="keyword">if</span> ((p.right = sr) != <span class="keyword">null</span>)</span><br><span class="line">              sr.parent = p;</span><br><span class="line">        	<span class="comment">//将s节点的左节点赋值为pl，如果pl不为空，则将pl的父节点赋值为s节点</span></span><br><span class="line">          <span class="keyword">if</span> ((s.left = pl) != <span class="keyword">null</span>)</span><br><span class="line">              pl.parent = s;</span><br><span class="line">        	<span class="comment">//将s的父节点赋值为p的父节点pp</span></span><br><span class="line">        	<span class="comment">//如果pp为空，则p节点为root节点，交换后称为新的root节点</span></span><br><span class="line">          <span class="keyword">if</span> ((s.parent = pp) == <span class="keyword">null</span>)</span><br><span class="line">              root = s;</span><br><span class="line">        	<span class="comment">//如果p不为root节点，并且p是pp得右节点，则将pp的左节点赋值为s节点</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">              pp.left = s;</span><br><span class="line">        	<span class="comment">//如果p不为root节点，并且p是pp的右节点，则将pp的右节点赋值为s节点</span></span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">              pp.right = s;</span><br><span class="line">        	<span class="comment">//寻找replacement节点，用来替换掉p节点</span></span><br><span class="line">        	<span class="comment">//如果sr不为空，则replacement节点为sr，因为s没有左节点，所以使用s的右节点来替换p的位置</span></span><br><span class="line">          <span class="keyword">if</span> (sr != <span class="keyword">null</span>)</span><br><span class="line">              replacement = sr;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">              replacement = p;</span><br><span class="line">      &#125;</span><br><span class="line">    	<span class="comment">//如果p的右节点不为空，有节点为空，replacement节点为p的左节点</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (pl != <span class="keyword">null</span>)</span><br><span class="line">          replacement = pl;</span><br><span class="line">    	<span class="comment">//如果p的右节点不为空，左节点为空，replacement节点为p的右节点</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (pr != <span class="keyword">null</span>)</span><br><span class="line">          replacement = pr;</span><br><span class="line">    	<span class="comment">//如果p的左右节点都为空，即p为叶子节点，replacement节点为p节点本身</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          replacement = p;</span><br><span class="line">    	<span class="comment">//使用replacement节点替换掉p节点的位置，将p节点移除</span></span><br><span class="line">      <span class="keyword">if</span> (replacement != p) &#123; <span class="comment">//如果p节点不是叶子节点</span></span><br><span class="line">        	<span class="comment">//将p节点的父节点赋值给replacement节点的父节点，同时赋值给pp节点</span></span><br><span class="line">          TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent;</span><br><span class="line">        	<span class="comment">//如果p没有父节点，即p为root节点，则将root节点赋值为replacement节点即可</span></span><br><span class="line">          <span class="keyword">if</span> (pp == <span class="keyword">null</span>)</span><br><span class="line">              root = replacement;</span><br><span class="line">        	<span class="comment">//如果p不是root节点，即p为root节点，则将pp的左节点赋值为替换节点replacement</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">              pp.left = replacement;</span><br><span class="line">        	<span class="comment">//如果p不是root节点，并且p为pp的右节点，则将pp的右节点赋值为替换节点replacement</span></span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">              pp.right = replacement;</span><br><span class="line">        	<span class="comment">//p节点的位置已经被完整的替换为replacement，将P节点清空，以便垃圾收集器回收</span></span><br><span class="line">          p.left = p.right = p.parent = <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//如果p节点不为红色则进行红黑树删除平衡调整</span></span><br><span class="line">    	<span class="comment">//如果删除的节点是红色则不会破坏红黑树的平衡无需调整</span></span><br><span class="line">      TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement);</span><br><span class="line"><span class="comment">//如果p节点为叶子节点，则简单的将p节点去除即可</span></span><br><span class="line">      <span class="keyword">if</span> (replacement == p) &#123;  <span class="comment">// detach</span></span><br><span class="line">          TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">        	<span class="comment">//将p的parent属性设置为空</span></span><br><span class="line">          p.parent = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">if</span> (pp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            	<span class="comment">//如果p节点为父节点的左节点，则将父节点的左节点赋值为空</span></span><br><span class="line">              <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                  pp.left = <span class="keyword">null</span>;</span><br><span class="line">            	<span class="comment">//如果p节点为父节点的右节点，则将父节点的右节点赋值为空</span></span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.right)</span><br><span class="line">                  pp.right = <span class="keyword">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (movable)</span><br><span class="line">        	<span class="comment">//将root节点移到索引位置的头节点</span></span><br><span class="line">          moveRootToFront(tab, r);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


    </article>
    <!-- license  -->
    
        <div class="license-wrapper">
            <p>原文作者：<a href="https://github.com/leisurexi">leisurexi</a>
            <p>原文链接：<a href="https://github.com/leisurexi/category/2019/08/15/集合/HashMap.html">https://github.com/leisurexi/category/2019/08/15/集合/HashMap.html</a>
            <p>发表日期：<a href="https://github.com/leisurexi/category/2019/08/15/集合/HashMap.html">August 15th 2019, 10:06:00 am</a>
            <p>更新日期：<a href="https://github.com/leisurexi/category/2019/08/15/集合/HashMap.html">January 18th 2020, 4:37:01 pm</a>
            <p>版权声明：本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p>
        </div>
    
    <!-- paginator  -->
    <ul class="post-paginator">
        <li class="next">
            
                <div class="nextSlogan">Next Post</div>
                <a href= "/category/2019/09/28/并发/线程池.html" title= "线程池">
                    <div class="nextTitle">线程池</div>
                </a>
            
        </li>
        <li class="previous">
            
                <div class="prevSlogan">Previous Post</div>
                <a href= "/category/2019/08/10/CentOS 7/CentOS 7 下RabbitMQ 3.7 安装与配置.html" title= "CentOS 7下安装RabbitMQ 3.7">
                    <div class="prevTitle">CentOS 7下安装RabbitMQ 3.7</div>
                </a>
            
        </li>
    </ul>
    <!-- 评论插件 -->
    <!-- 来必力City版安装代码 -->

    <div id="lv-container" data-id="city" data-uid= MTAyMC81MDIyOS8yNjcxOQ==>
        <script type="text/javascript">
            (function (d, s) {
                var j, e = d.getElementsByTagName(s)[0];
                if (typeof LivereTower === 'function') { return; }
                j = d.createElement(s);
                j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
                j.async = true;

                e.parentNode.insertBefore(j, e);
            })(document, 'script');
        </script>
        <noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
    </div>

<!-- City版安装代码已完成 -->
    
    
    <!-- partial('_partial/comment/changyan') -->
    <!--PC版-->


    
    

    <!-- 评论 -->
</main>
            <!-- profile -->
            
        </div>
        <footer class="footer footer-unloaded">
    <!-- social  -->
    
    <div class="social">
        
    
        
            
                <a href="mailto:leisurexi@gmail.com" class="iconfont-archer email" title=email ></a>
            
        
    
        
            
                <a href="https://github.com/leisurexi" class="iconfont-archer github" target="_blank" title=github></a>
            
        
    
        
            
                <span class="iconfont-archer wechat" title=wechat>
                  
                  <img class="profile-qr" src="/assets/wechat.png" />
                </span>
            
        
    
        
            
                <span class="iconfont-archer qq" title=qq>
                  
                  <img class="profile-qr" src="/assets/qq.png" />
                </span>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    

    </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">Archer</a></span>
    </div>
    <!-- 不蒜子  -->
    
    <div class="busuanzi-container">
    
     
    <span id="busuanzi_container_site_pv">PV: <span id="busuanzi_value_site_pv"></span> :)</span>
    
    </div>
    
</footer>
    </div>
    <!-- toc -->
    
    <div class="toc-wrapper" style=
    







top:50vh;

    >
        <div class="toc-catalog">
            <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
        </div>
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#基本属性"><span class="toc-number">1.</span> <span class="toc-text">基本属性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字段"><span class="toc-number">2.</span> <span class="toc-text">字段</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#静态工具方法"><span class="toc-number">3.</span> <span class="toc-text">静态工具方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#hash"><span class="toc-number">3.1.</span> <span class="toc-text">hash</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#compareComparables"><span class="toc-number">3.2.</span> <span class="toc-text">compareComparables</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#compareComparables-1"><span class="toc-number">3.3.</span> <span class="toc-text">compareComparables</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tableSizeFor"><span class="toc-number">3.4.</span> <span class="toc-text">tableSizeFor</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#构造函数"><span class="toc-number">4.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#常用方法"><span class="toc-number">5.</span> <span class="toc-text">常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#get"><span class="toc-number">5.1.</span> <span class="toc-text">get</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#getNode"><span class="toc-number">5.2.</span> <span class="toc-text">getNode</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#put"><span class="toc-number">5.3.</span> <span class="toc-text">put</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#putVal"><span class="toc-number">5.4.</span> <span class="toc-text">putVal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#putAll"><span class="toc-number">5.5.</span> <span class="toc-text">putAll</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#putMapEntries"><span class="toc-number">5.6.</span> <span class="toc-text">putMapEntries</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#remove"><span class="toc-number">5.7.</span> <span class="toc-text">remove</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#removeNode"><span class="toc-number">5.8.</span> <span class="toc-text">removeNode</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#红黑树（TreeNode）相关方法"><span class="toc-number">5.9.</span> <span class="toc-text">红黑树（TreeNode）相关方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#getTreeNode"><span class="toc-number">5.10.</span> <span class="toc-text">getTreeNode</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#find"><span class="toc-number">5.11.</span> <span class="toc-text">find</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#putTreeVal"><span class="toc-number">5.12.</span> <span class="toc-text">putTreeVal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tieBreakOrder"><span class="toc-number">5.13.</span> <span class="toc-text">tieBreakOrder</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#treeifyBin"><span class="toc-number">5.14.</span> <span class="toc-text">treeifyBin</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#treeify"><span class="toc-number">5.15.</span> <span class="toc-text">treeify</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#moveRootToFront"><span class="toc-number">5.16.</span> <span class="toc-text">moveRootToFront</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#checkInvariants"><span class="toc-number">5.17.</span> <span class="toc-text">checkInvariants</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#split"><span class="toc-number">5.18.</span> <span class="toc-text">split</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#untreeify"><span class="toc-number">5.19.</span> <span class="toc-text">untreeify</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#remove-1"><span class="toc-number">5.20.</span> <span class="toc-text">remove</span></a></li></ol></li></ol>
    </div>
    
    <div class="back-top iconfont-archer">&#xe639;</div>
    <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
          <div class="sidebar-panel-archives">
    <!-- 在ejs中将archive按照时间排序 -->
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 25
        </div>
        <!-- search  -->
        
    </div>
    
    <div class="post-archive">
    
    
    
    
    <div class="archive-year"> 2020 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/07</span><a class="archive-post-title" href= "/category/2020/06/07/Spring IoC/Spring IoC 容器的扩展.html" >Spring IoC 容器的扩展</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/30</span><a class="archive-post-title" href= "/category/2020/05/30/Spring IoC/Spring IoC component-scan 节点详解.html" >Spring IoC component-scan 节点详解</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/21</span><a class="archive-post-title" href= "/category/2020/05/21/Spring IoC/Spring IoC createBean 方法详解.html" >Spring IoC createBean 方法详解</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/18</span><a class="archive-post-title" href= "/category/2020/05/18/CentOS 7/CentOS 7 Zookeeper 和 Kafka 集群搭建.html" >CentOS 7 Zookeeper 和 Kafka 集群搭建</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/18</span><a class="archive-post-title" href= "/category/2020/05/18/CentOS 7/CentOS 7 Nacos 集群搭建.html" >CentOS 7 下 Nacos 集群搭建</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/26</span><a class="archive-post-title" href= "/category/2020/04/26/ELK/Docker 搭建ELK集群步骤.html" >Docker 搭建 ELK 集群步骤</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/21</span><a class="archive-post-title" href= "/category/2020/04/21/Spring IoC/Spring IoC getBean 方法详解.html" >Spring IoC getBean 方法详解</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/14</span><a class="archive-post-title" href= "/category/2020/04/14/Spring IoC/Spring XML Bean 定义的加载和注册.html" >Spring XML Bean 定义的加载和注册</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/01</span><a class="archive-post-title" href= "/category/2020/02/01/JVM/Java虚拟机性能监控和故障处理工具.html" >Java虚拟机性能监控和故障处理工具</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/28</span><a class="archive-post-title" href= "/category/2020/01/28/JVM/JVM 类加载机制.html" >JVM 类加载机制</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/28</span><a class="archive-post-title" href= "/category/2020/01/28/JVM/JVM垃圾收集相关的常用参数.html" >JVM垃圾收集相关的常用参数</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/21</span><a class="archive-post-title" href= "/category/2020/01/21/MySQL/MySQL索引.html" >MySQL索引</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/18</span><a class="archive-post-title" href= "/category/2020/01/18/MySQL/MySQL EXPLAIN详解.html" >MySQL EXPLAIN详解</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/18</span><a class="archive-post-title" href= "/category/2020/01/18/MySQL/MySQL事务.html" >MySQL事务</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/13</span><a class="archive-post-title" href= "/category/2020/01/13/RabbitMQ/RabbitMQ镜像集群模式.html" >RabbitMQ镜像集群模式</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2019 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/28</span><a class="archive-post-title" href= "/category/2019/12/28/Redis/Redis Cluster.html" >Redis Cluster</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/28</span><a class="archive-post-title" href= "/category/2019/09/28/并发/线程池.html" >线程池</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/15</span><a class="archive-post-title" href= "/category/2019/08/15/集合/HashMap.html" >HashMap</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/10</span><a class="archive-post-title" href= "/category/2019/08/10/CentOS 7/CentOS 7 下RabbitMQ 3.7 安装与配置.html" >CentOS 7下安装RabbitMQ 3.7</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/28</span><a class="archive-post-title" href= "/category/2019/05/28/集合/LinkedList.html" >LinkedList</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/26</span><a class="archive-post-title" href= "/category/2019/05/26/设计模式/单例模式.html" >单例模式</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/26</span><a class="archive-post-title" href= "/category/2019/05/26/设计模式/迭代器模式.html" >迭代器模式</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/18</span><a class="archive-post-title" href= "/category/2019/05/18/集合/Collection.html" >Collection</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/18</span><a class="archive-post-title" href= "/category/2019/05/18/集合/ArrayList.html" >ArrayList</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/16</span><a class="archive-post-title" href= "/category/2019/05/16/设计模式/备忘录模式.html" >备忘录模式</a>
        </li>
    
    </div>
  </div>
        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
    
        <span class="sidebar-tag-name" data-tags="CentOS 7"><span class="iconfont-archer">&#xe606;</span>CentOS 7</span>
    
        <span class="sidebar-tag-name" data-tags="JVM"><span class="iconfont-archer">&#xe606;</span>JVM</span>
    
        <span class="sidebar-tag-name" data-tags="设计模式"><span class="iconfont-archer">&#xe606;</span>设计模式</span>
    
        <span class="sidebar-tag-name" data-tags="Zookeeper"><span class="iconfont-archer">&#xe606;</span>Zookeeper</span>
    
        <span class="sidebar-tag-name" data-tags="Kafka"><span class="iconfont-archer">&#xe606;</span>Kafka</span>
    
        <span class="sidebar-tag-name" data-tags="RabbitMQ"><span class="iconfont-archer">&#xe606;</span>RabbitMQ</span>
    
        <span class="sidebar-tag-name" data-tags="集合"><span class="iconfont-archer">&#xe606;</span>集合</span>
    
        <span class="sidebar-tag-name" data-tags="并发"><span class="iconfont-archer">&#xe606;</span>并发</span>
    
        <span class="sidebar-tag-name" data-tags="MySQL"><span class="iconfont-archer">&#xe606;</span>MySQL</span>
    
        <span class="sidebar-tag-name" data-tags="Nacos"><span class="iconfont-archer">&#xe606;</span>Nacos</span>
    
        <span class="sidebar-tag-name" data-tags="Spring IoC"><span class="iconfont-archer">&#xe606;</span>Spring IoC</span>
    
        <span class="sidebar-tag-name" data-tags="Redis"><span class="iconfont-archer">&#xe606;</span>Redis</span>
    
        <span class="sidebar-tag-name" data-tags="ELK"><span class="iconfont-archer">&#xe606;</span>ELK</span>
    
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
    缺失模块。<br/>
    1、请确保node版本大于6.2<br/>
    2、在博客根目录（注意不是archer根目录）执行以下命令：<br/>
    <span style="color: #f75357; font-size: 1rem; line-height: 2rem;">npm i hexo-generator-json-content --save</span><br/>
    3、在根目录_config.yml里添加配置：
    <pre style="color: #787878; font-size: 0.6rem;">
jsonContent:
  meta: false
  pages: false
  posts:
    title: true
    date: true
    path: true
    text: false
    raw: false
    content: false
    slug: false
    updated: false
    comments: false
    link: false
    permalink: false
    excerpt: false
    categories: true
    tags: true</pre>
    </div> 
    <div class="sidebar-tags-list"></div>
</div>
        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
        <span class="sidebar-category-name" data-categories="CentOS-7"><span class="iconfont-archer">&#xe60a;</span>CentOS-7</span>
    
        <span class="sidebar-category-name" data-categories="JVM"><span class="iconfont-archer">&#xe60a;</span>JVM</span>
    
        <span class="sidebar-category-name" data-categories="设计模式"><span class="iconfont-archer">&#xe60a;</span>设计模式</span>
    
        <span class="sidebar-category-name" data-categories="CentOS-7/Zookeeper"><span class="iconfont-archer">&#xe60a;</span>CentOS-7/Zookeeper</span>
    
        <span class="sidebar-category-name" data-categories="RabbitMQ"><span class="iconfont-archer">&#xe60a;</span>RabbitMQ</span>
    
        <span class="sidebar-category-name" data-categories="CentOS-7/Zookeeper/Kafka"><span class="iconfont-archer">&#xe60a;</span>CentOS-7/Zookeeper/Kafka</span>
    
        <span class="sidebar-category-name" data-categories="集合"><span class="iconfont-archer">&#xe60a;</span>集合</span>
    
        <span class="sidebar-category-name" data-categories="并发"><span class="iconfont-archer">&#xe60a;</span>并发</span>
    
        <span class="sidebar-category-name" data-categories="MySQL"><span class="iconfont-archer">&#xe60a;</span>MySQL</span>
    
        <span class="sidebar-category-name" data-categories="CentOS-7/MySQL"><span class="iconfont-archer">&#xe60a;</span>CentOS-7/MySQL</span>
    
        <span class="sidebar-category-name" data-categories="Spring-IoC"><span class="iconfont-archer">&#xe60a;</span>Spring-IoC</span>
    
        <span class="sidebar-category-name" data-categories="CentOS-7/MySQL/Nacos"><span class="iconfont-archer">&#xe60a;</span>CentOS-7/MySQL/Nacos</span>
    
        <span class="sidebar-category-name" data-categories="Redis"><span class="iconfont-archer">&#xe60a;</span>Redis</span>
    
        <span class="sidebar-category-name" data-categories="ELK"><span class="iconfont-archer">&#xe60a;</span>ELK</span>
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>
    </div>
</div> 
    <script>
    var siteMeta = {
        root: "/",
        author: "leisurexi"
    }
</script>
    <!-- CDN failover -->
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ === 'undefined')
        {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js">\x3C/script>')
        }
    </script>
    <script src="/scripts/main.js"></script>
    <!-- algolia -->
    
    <!-- busuanzi  -->
    
    <!-- <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script> -->
    <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    <!-- CNZZ  -->
    
    </div>
    <!-- async load share.js -->
    
        <script src="/scripts/share.js" async></script>    
     
    <script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/assets/koharu.model.json"},"display":{"position":"left","width":150,"height":300,"hOffset":75},"mobile":{"show":true},"react":{"opacity":0.7},"log":false});</script></body>
</html>


